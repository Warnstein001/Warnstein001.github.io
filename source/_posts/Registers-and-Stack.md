---
title: 从混淆到五迷：寄存器与栈的学习总结
date: 2025-11-30 12:39:01
categories:
  - 计算机
tags:
  - csapp
mathjax: false
---


# 🌟 栈、寄存器、栈帧、参数传递、寄存器构成 —— 完整总结（Markdown 版）
## 1. 寄存器 vs 栈：核心区别
● 寄存器（Register）

CPU 内部的高速存储单元

数量极少（几十个）

读写速度最快

存储：运算需要的中间值、指针、参数、临时数据

示例：rax, rbx, rsp, rip

● 栈（Stack）

进程在内存中的一块区域

速度快于堆，但比寄存器慢

存储：函数调用的返回地址、局部变量、被保存的寄存器、额外参数

栈遵循 LIFO（后进先出）

栈由寄存器（如 rsp）管理

## 2. 栈帧（Stack Frame）结构

典型 x86-64 System V ABI 栈帧（从高地址到低地址）：
```powershell
高地址
─────────────────────────
上一个函数的栈帧
─────────────────────────
返回地址
─────────────────────────
旧 rbp              ← rbp
─────────────────────────
局部变量
临时空间
─────────────────────────    ← rsp
低地址
```
构建过程（Prologue）

call foo

压入返回地址

push rbp

保存旧的基址指针

mov rbp, rsp

建立当前函数的栈帧基准

sub rsp, N

为局部变量分配空间

销毁过程（Epilogue）

mov rsp, rbp

pop rbp

ret

## 3. 参数是放寄存器还是栈？

取决于 ABI（调用约定）。

### ⭐ x86-64 System V ABI（Linux / macOS）
整数 / 指针参数（前 6 个）：
```txt
1 → rdi
2 → rsi
3 → rdx
4 → rcx
5 → r8
6 → r9
```

超过 6 个放栈上（右 → 左压栈）
浮点参数：

前 8 个在 xmm0~xmm7

### ⭐ Windows x64 ABI（MSVC）
前 4 个参数：
```txt
rcx, rdx, r8, r9
```

超过部分放栈上

并且 caller 必须准备 32 字节 shadow space。

### ⭐ 32-bit x86 ABI

所有参数都在栈上

调用顺序：右 → 左 push

### 参数访问方式

参数可能：

直接用寄存器（高效）

被 spill 到栈中（调试模式或复杂函数中）

## 4. 寄存器是怎么构成的？

寄存器的构成包括：
物理层（硬件） + 架构层（ISA）

### 4.1 硬件构成（物理寄存器）

寄存器由以下构成：

● D 触发器（D Flip-Flops）

1 bit = 1 个触发器

64 位寄存器 = 64 个触发器 + 读写电路

● 多端口读写电路

支持同时读写多个寄存器

● Forwarding / Bypassing（旁路网络）

避免流水线停顿

● 寄存器重命名（Register Renaming）

将“架构寄存器”映射到大量“物理寄存器”，用于乱序执行。

架构寄存器：程序能看到的那些（如 rax）
物理寄存器：CPU 内部真正的数量（可能上百个）

### 4.2 架构寄存器分类（x86-64）
● 通用寄存器（GPR）
```powershell
rax, rbx, rcx, rdx,
rsi, rdi,
rbp, rsp,
r8 ~ r15
```

● 指令指针寄存器（RIP）
● 标志寄存器（RFLAGS）
● 浮点 / SIMD 寄存器
```nginx
xmm0 ~ xmm31（128 位）
ymm0 ~ ymm31（256 位）
zmm0 ~ zmm31（512 位）
```

● 控制寄存器（CR0, CR2, CR3, CR4…）
● 段寄存器（CS、DS、FS、GS…）
● 调试寄存器（DR0~DR7）
### 4.3 架构寄存器 vs 物理寄存器
```markdown
┌──────────────────────────────┐
│     Physical Registers        │
│   (真实数量远 > 架构寄存器)   │
└──────────────────────────────┘
              ▲
      寄存器重命名器
              ▼
┌──────────────────────────────┐
│  Architectural Registers      │
│ rax rbx ... xmm0 ... rip ... │
└──────────────────────────────┘
```

现代 CPU 的执行效率依赖：

乱序执行（OoO）

寄存器重命名

指令融合

确保流水线不断气

## 5. 整体知识结构图
```markdown
           寄存器
      ┌──────────────┬───────────────┐
      │ 架构寄存器    │ 物理寄存器     │
      │ 程序员可见    │ 乱序执行使用   │
      └──────────────┴───────────────┘

                 ↓ 管理（rsp、rip）

            栈内存（Stack）
 ┌───────────────────────────────────┐
 │ 返回地址、旧 rbp、局部变量、spill │
 └───────────────────────────────────┘
 ```
